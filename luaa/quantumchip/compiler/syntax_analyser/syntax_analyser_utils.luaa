/*-----------------------------------
    Syntax analyser utils
    Included by syntax_analyser.luaa file.
-------------------------------------*/

partial class QC_SyntaxAnalyser {
       
    var Output = { }; // Output instruction table
    var Time = 0; // Analysis time
    
    var InputTokens;
    
    var CurrentTokenIndex = 0;
    var CurrentToken;
       
    /*
        Constructor
    */
    function QC_SyntaxAnalyser(input) {
        var startTime = SysTime();
        
        assert(input != null, "Input is nil. List of tokens expected.");
        
        this.InputTokens = input;
        this:Analyse();
        
        this.Time = SysTime() - startTime;
    }
    
    /*-----------------------------------
        Token moving
        Token structure: { Type, Value, Line, Position }
    -------------------------------------*/
    
    /*
        Goes to the next token. Updates CurrentToken value.
        Returns false if EOF.
    */
    function NextToken() {
        this.CurrentTokenIndex = this.CurrentTokenIndex + 1;
        
        if(this.CurrentTokenIndex > #this.InputTokens)
            return false;
            
        this.CurrentToken = this.InputTokens[this.CurrentTokenIndex];
            
        return true;
    }
    
    /*
        Goes to the previous token. Updates CurrentToken value.
        Returns false if EOF. IN ANALYSIS USE AS RARELY AS POSSIBLE!
    */
    function PrevToken() {
        this.CurrentTokenIndex = this.CurrentTokenIndex - 1;
        
        if(this.CurrentTokenIndex < 1)
            return false;
            
        this.CurrentToken = this.InputTokens[this.CurrentTokenIndex];
            
        return true;
    }
    
    /*
        Returns if NextToken impossible, end of file.
    */
    function CheckEOF() {
        return this.CurrentTokenIndex + 1 > #this.InputTokens;
    }
    
    /*-----------------------------------
        Token accepting
    -------------------------------------*/
    
    /*
        Returns true, if next token is of specified type (and optionally value).
    */
    function AcceptToken(type, value) {
        var next = this.InputTokens[this.CurrentTokenIndex + 1];
        
        if(next && next[1] == type && (!value ? true : next[2] == value)) {
            this:NextToken();
            return true;
        }
        
        return false;
    }
    
    /*
        Ditto. Multiple tokens.
    */
    function AcceptTokens(type, valueList) {
        var next = this.InputTokens[this.CurrentTokenIndex + 1];
        
        if(next && next[1] == type && table.HasValue(valueList, next[2])) {
            this:NextToken();
            return true;
        }
        
        return false;
    }
    
    function AcceptKeyword(value) {
        return this:AcceptToken("k", value);
    }
    
    function AcceptKeywords(...) { 
        return this:AcceptTokens("k", { ... });
    } 
    
    function AcceptSymbol(value) {
        return this:AcceptToken("s", value);
    }
    
    function AcceptSymbols(...) {
        return this:AcceptTokens("s", { ... });
    }
    
    function AcceptIdentifier() {
        return this:AcceptToken("i");
    }
    
    function AcceptNumber() {
        return this:AcceptToken("n");
    }
    
    function AcceptString() {
        return this:AcceptToken("S");
    }
    
    /*-----------------------------------
        Token requiring
    -------------------------------------*/
    
    function RequireToken(type, value, message) {
        this.CurrentTokenIndex = this.CurrentTokenIndex + 1;
        
        if(this.CurrentTokenIndex > #this.InputTokens)
            error("Unexpected end of file.");
            
        this.CurrentToken = this.InputTokens[this.CurrentTokenIndex];
            
        if(this.CurrentToken[1] != type || (!value ? false : this.CurrentToken[2] != value))
            error(message ?? "Token expected.");
        
        return this.CurrentToken;
    }
    
    function RequireKeyword(value) {
        return this:RequireToken("k", value, "Keyword '" .. value .. "' expected.");
    }
    
    function RequireSymbol(value) {
        return this:RequireToken("s", value, "Symbol '" .. value .. "' expected.");
    }
    
    function RequireIdentifier() {
        return this:RequireToken("i", null, "Identifier expected.");
    }
    
    function RequireNumber() {
        return this:RequireToken("n", null, "Number expected.");
    }
    
    function RequireString() {
        return this:RequireToken("S", null, "Number expected.");
    }
    
}

/*-----------------------------------
    Testing
-------------------------------------*/

#if DEBUG 
QC.DoTest();
#endif 